---
layout: post
title: Arduino Multi-tasking
meta: Concept
category: IoT
comments: true
---
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css">
    <link rel="stylesheet" type="text/css" href="/css/pageframe.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <style>
      @import url(//fonts.googleapis.com/earlyaccess/nanumpenscript.css);
    </style>
  <!--
  수식용 스크립트 MathJax
  -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      //jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$'] ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
      //,
      //displayAlign: "left",
      //displayIndent: "2em"
    });
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
  </head>
  <body>	  
<!--
카테고리: Categories <h3 class="Categories BasicFontSet"></h3>
날짜: Date 
      {% for news in site.categories.analysis %}
        {% if news.title == 'Testing css'%}
          <a class="Date">{{ news.date | date_to_string }}</a> | <a class="post-tag">{{ page.category }}</a>
        {% endif %}
      {% endfor %}
태그: Tags <a class="post-tag">태그 내용</a>
posting한곳: Posting <blockquote><p class="posting">포스팅 </p></blockquote>
주제: MainTitle <h1 class="BasicFontSet"></h1>
소제: SubTitle <h2 class="BasicFontSet"></h2>
단락: Paragraph <p class="Paragraph"></p>
내용: Contents <p class="Contents"></p>
이미지: Imgsize - media query 적용
이미지 text: Imgtext
      <p class="Imgtext">
          <img src="이미지 주소" class="concept"></br>
          <내용></br>
      </p>
전체 코드 URL: CodeURL
참고자료: Reference <blockquote><p class="Reference">가져온곳: <a class="Reference"> URL</a></p>
-->
      <a>
	<h3 class="Categories BasicFontSet">Arduino Multi-tasking</h3>
	{% for news in site.categories.IoT %}
        {% if news.title == 'Arduino Multi-tasking'%}
          <a class="Date">{{ news.date | date_to_string }}</a> | <a class="post-tag" href="https://ysw0421.github.io/contents/categories/#IoT">{{ page.category }}</a>
        {% endif %}
        {% endfor %}
     </a>
	<blockquote><p class="posting">포스팅 </p></blockquote>
<h2 class="BasicFontSet">다중 작업 처리(Multi-tasking)</h2>
	아두이노는 운영체제가 없고 강력한 프로세스 하나의 일만 처리한다.
	보통 delay() 함수를 사용해 프로그램을 잠시 기다리는 방법을 사용한다.
	하지만, delay()를 사용하는 것은 함수가 수행되는 동안에는 어떤 입력도 받을 수 없고, 출력도 할 수 없다.
	100% 프로세서에 물려있다고 할 수 있다. 
	그래서 아두이노 프로세서는 Blink 하는 동안 아무일도 할 수 없다. 
	해결책으로 delay()대신 millis()함수를 사용하여 시간을 감시해보자.
	그래서 우리는 첫번째로 delay()를 사용하지 않는 프로그램을 만들어 보려고한다.
	우리는 이것을 Blink without delay라고 부르자.</br>
	구현이 복잡해 보이겠지만 $State Machine$이라는 중요한 개념을 알게된다.</br>
	$State + Machine = State Machine$</br>
	</br>
	</br>
<pre><code>
long previousMillis = 0;   
long interval = 1000; 
void loop()
{
unsigned long currentMillis = millis();
     if(currentMillis - previousMillis > interval) 
    {
        previousMillis = currentMillis;
	원하는 기능 함수
     }
}
</code></pre>
</br>
</br>
	interval에 시간을 주어 원하는 시간마다 원하는 기능을 체크하는 코드이다.</br>
	</br>
	이번에는 On time 과 Off time 이 다르게 성정되어 동작하는 프로그래밍을 해보자.
	우리는 이것을 FlashWithoutDelay 라고 부르자.</br>
	</br>
	</br>
	</br>
<pre><code>
int State = LOW;
long previousMillis = 0;   
long interval = 1000; 
void loop()
{
      unsigned long currentMillis = millis();
      if((State == HIGH) && (currentMillis - previousMillis >= OnTime))
      {
        State = LOW;  // Turn it off
        previousMillis = currentMillis;
        원하는 기능 함수
      }
      else if ((State == LOW) && (currentMillis - previousMillis >= OffTime))
      {
        State = HIGH;  // turn it on
        previousMillis = currentMillis;
        원하는 기능 함수
      }
}
</code></pre>
</br>
</br>
	LOW 인지 HIGH 인지를 추적하는 변수($State$)가 있다. 
	그리고 마지막 변경이 언제 일어 났는지를 추적하는 변수($previousMillis$)가 있다. 
	이 두가지 변수가 $State Machine$의 주요 부분이다. 
	추가로 2가지의 기능을 만든다고 하면 추가의 시간 간격 관리를 해줘 프로그래밍하면 된다.
	코드를 반복해서 쓰는 것이 반복처럼 보이니 클래스를 만들어 반복해서 쓰도록 하자.
	하지만, 이 프로잭트에서는 클래스까지는 필요가 없다. 함수까지만 쓰도록 하자.</br>
</br>
</br>
</br>
<pre><code>
#define R0 10000
#define T0 25 //room temperature
#define B 4200 //the coefficient of the thermistor
#define SERISR 10000 //seris resistor 10K

int LledPin = 13;
int TledPin = 9;
int CledPin = 7;
int AledPin = 2;

long previousMillis1 = 0;
long previousMillis2 = 0;
long previousMillis3 = 0;
long previousMillis4 = 0;
long interval = 1000;  

void CheckOut(long currentMillis, int ledPin, long previousMillis, float data, int value)
{
  if((data > value) && ((currentMillis - previousMillis) > interval))
  {
    previousMillis = currentMillis;
    digitalWrite(ledPin, HIGH);
  }
  else if((data <= value) && ((currentMillis - previousMillis) > interval))
  {
    previousMillis = currentMillis;
    digitalWrite(ledPin, LOW);
  }
}

void setup() {
  Serial.begin(9600);
  // 9번 핀을 출력으로 설정
	pinMode(LledPin, OUTPUT);
	pinMode(TledPin, OUTPUT);
	pinMode(CledPin, OUTPUT);
	pinMode(AledPin, OUTPUT);
}
void loop() {
  // 조도 센서 값
  int Ldata = analogRead(A0);
  
  
  // 온도 센서 값
  float thermistorRValue = 0;
	thermistorRValue = 1023.0 / analogRead(A1) - 1;
	thermistorRValue = SERISR / thermistorRValue;
	
	float temperature = 0;
	temperature = thermistorRValue / R0; // R/R0
	temperature = log(temperature);
	temperature = temperature / B;
	temperature = temperature + 1.0 / (T0 + 273.15);
	temperature = 1.0 / temperature;
	temperature -= 273.15 ;// kelvins to C
  float Tdata = temperature;


  // MQ-7 일산화 탄소 센서 값
	int MQ7data = analogRead(A2);
  
  // MQ-3 알코올 센서 값
  int MQ3data = analogRead(A3);
  
  unsigned long currentMillis = millis();
  CheckOut(currentMillis,LledPin,previousMillis1,Ldata,800);
  CheckOut(currentMillis,TledPin,previousMillis2,Tdata,27);
  CheckOut(currentMillis,CledPin,previousMillis3,MQ7data,2);
  CheckOut(currentMillis,AledPin,previousMillis4,MQ3data,-1);
}
</code></pre>
</br>
</br>
<h2 class="BasicFontSet">인터럽트(nterrupt)</h2>
	이제 인터럽트에 대해 알아보자.
	타이머 인터럽트를 활용하여 모든 일이 시계처럼 작동하도록하는 방법을 배운다.
	외부 이벤트에 대한 알림을 제공하기 위해 외부 인터럽트를 사용하는 방법 또한 배운다.
	여기서 나오는 용어들 인터럽트, 타이머 인터럽트, 외부 인터럽트들에 대한 간단한 설명을 하면 다음과 같다.</br>
	</br>
	타이머를 알기 위해서는 먼저 인터럽트라는 개념을 조금 알아둘 필요가 있다.
	인터럽트는 중요한 일이 발생하면 하던일을 잠시 멈추고 중요한 일을 먼저하는 것을 말한다. 
	인터럽트가 발생했다는 말은 지금하던 일보다 아주 중요한 일이 발생하여 하던 일을 잠시 중단하고 그 일(인터럽트를 건 일)을 해야만 하게 되었다는 뜻이다.</br>
	</br>
	마이크로프로세서에서 인터럽트란 CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우에 CPU에게 알려 처리할 수 있도록 하는 것을 말한다.</br>
	</br>
	타이머 인터럽트는 CPU 내부에서 일정한 주기로 발생되는 시간에 인터럽트를 발생시켜 중요한 일들을 처리하는 인터럽트를 말한다.
	외부 인터럽트란 외부의 입출력 장치나 외부 디바이스에서 발생된 중요하고 급한 신호를 감지하여 처리해 주는 방법의 일종이다.</br>
	</br>
	이 프로잭트에서 인터럽트 개념이 어떻게 사용될지 알아보자.</br>
	</br>
<p class="Paragraph">인터럽트란 무엇인가?</p>
	
	인터럽트는 프로세서가 수행중인 작업을 즉시 중단하고 우선 순위가 높은 일부 처리를 처리하도록 알리는 신호이다.
	우선 순위가 높은 우선순위를 먼저 처리하는 것을 인터럽트 처리기라 한다.
	인터럽트 처리기는 다른 void 함수와 비슷하다.
	우선 인터럽트 하나를 사용하기로 하고 할당을 하게되면 인터럽트 신호가 트리거 될 때마다 할당된 함수가 호출된다.
	인터럽트 처리를 마치고 처리기에서 돌아오면 이전에 실행중이던 작업을 계속 진행한다.</br>
	</br>
<p class="Paragraph">인터럽트들은 어디서 발생이 되나?</p>
	
	여러 소스에서 인터럽트를 생성할 수 있다.
	타이머는 Arduino에 있는 여러 타이머 중 하나에서 인터럽트를 발생시킨다.
	외부 인터럽트 핀 중 하나의 상태 변화로 인한 인터럽트가 발생할 수 있다.
	여러 핀 그룹 중 하나의 상태변화로 인한 핀 변경 인터럽트도 발생한다.</br>
	</br>
<p class="Paragraph">인터럽트를 사용함으로 얻는 장점은 무엇인가?</p>
	
	인터럽트를 사용하면 우선 순위가 높은 인터럽트 조건을 계속 확인하기 위해 루프 코드를 작성할 필요가 없다.
	응답이 느리거나 장시간 CPU를 소유하며 실행되는 프로그램 코드들 때문에 급하고 중요하게 처리될 일을 잊는 일은 없다.
	즉, 프로세서는 인터럽트가 발생할 때 자동으로 중지하고 인터럽트 처리기를 호출한다.
	따라서, 우리는 인터럽트가 일어날 때 실행되는 인터럽트에 응답하는 코드를 작성하기만 하면 된다.</br>
	</br>
<p class="Paragraph">타이머 인터럽트</p>
	
	타이머와 타이머 인터럽트를 통해 밀리 세컨드 당 한번 우리에게 알려주는 타이머를 설정할 수 있따.
	타이머가 실제로 시계를 확인할 때가 되었음을 알려줄 것이다.</br>
	</br>
<p class="Paragraph">Arduino 타이머</p>
	
	Arduino 내부에는 마이크로 컨트롤러 내부에 Timer0, Timer1 및 Timer2의 3개의 타이머가 있다.
	Timer()은 이미 millis()에 의해보고 된 밀리 초 카운터를 업데이트하기 위해 밀리 초 인터럽트를 생성하도록 설정된다.
	Timer0는 인터럽트를 생성하도록 할 것이다.</br>
	</br>
<p class="Paragraph">Frequency및 Counter</p>
	
	Timer는 16MHz 시스템 클록에서 파생 된 일부 주파수에서 계산되는 간단한 Counter이다. 
	주파수 및 다양한 계수 모드를 변경하기 위해 클럭 발생 수를 구성 할 수 있다. 
	Timer가 특정 Counter에 도달하면 인터럽트를 생성하도록 구성 할 수 있다는 말이다.</br>
	</br>
	Timer0은 0에서 255까지 카운트하고 255가 넘어갈 때마다 인터럽트를 생성하는 8 비트 카운터가 된다. 
	그것은 우리에게 976.5625 Hz의 인터럽트 속도를 제공하기 위해 기본적으로 64의 클록 제수를 사용한다 
	(우리의 목적을 위해 1KHz에 충분히 가깝다). 
	우리는 millis () 를 정확히 지켜야 하기 때문에 Timer0의 freqency를 일정한 수준으로 지켜야 한다. </br>
	</br>
<p class="Paragraph">Comparison Register</p>
	
	Arduino Timer에는 여러 구성 레지스터가 있습니다. 
	이것들은 Arduino IDE에 정의 된 특수 기호를 사용하여 읽거나 쓸 수 있습니다. 
	이 모든 레지스터와 기능에 대한 자세한 설명은 아래의 "추가 정보"링크를 참조하십시오.</br>
	</br>
	Timer0에 대한 Comparison Register(이 레지스터는 OCR0A라고 함)를 설정하여 그 카운트 중간에 다른 인터럽트를 생성합니다. 
	모든 틱에서 타이머 카운터는 비교 레지스터와 비교되며, 같으면 인터럽트가 생성됩니다.</br>
	</br>
	아래의 코드는 카운터 값이 0xAF를 통과 할 때마다 'TIMER0_COMPA'인터럽트를 생성합니다.</br>
	</br>
	그런 다음 "TIMER0_COMPA_vect"로 알려진 타이머 인터럽트 벡터에 대한 인터럽트 처리기를 정의합니다. 
	이 인터럽트 처리기에서는 루프에서 수행했던 모든 작업을 수행합니다.</br>
	<blockquote><p class="Reference">가져온곳: <a class="Reference"> https://fishpoint.tistory.com/2095?category=626454</a></p></blockquote>
  </body>
</html>
