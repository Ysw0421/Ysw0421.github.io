---
layout: post
title: C Compiler
meta: Concept
category: C
comments: true
---
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css">
    <link rel="stylesheet" type="text/css" href="/css/pageframe.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <style>
      @import url(//fonts.googleapis.com/earlyaccess/nanumpenscript.css);
    </style>
  <!--
  수식용 스크립트 MathJax
  -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      //jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$'] ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
      //,
      //displayAlign: "left",
      //displayIndent: "2em"
    });
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
  </head>
  <body>	  
<!--
카테고리: Categories <h3 class="Categories BasicFontSet"></h3>
날짜: Date 
      {% for news in site.categories.analysis %}
        {% if news.title == 'Testing css'%}
          <a class="Date">{{ news.date | date_to_string }}</a> | <a class="post-tag">{{ page.category }}</a>
        {% endif %}
      {% endfor %}
태그: Tags <a class="post-tag">태그 내용</a>
posting한곳: Posting <blockquote><p class="posting">포스팅 </p></blockquote>
주제: MainTitle <h1 class="BasicFontSet"></h1>
소제: SubTitle <h2 class="BasicFontSet"></h2>
단락: Paragraph <p class="Paragraph"></p>
내용: Contents <p class="Contents"></p>
이미지: Imgsize - media query 적용
이미지 text: Imgtext
      <p class="Imgtext">
          <img src="이미지 주소" class="concept"></br>
          <내용></br>
      </p>
전체 코드 URL: CodeURL
참고자료: Reference <blockquote><p class="Reference">가져온곳: <a class="Reference"> URL</a></p>
-->
      <a>
	<h3 class="Categories BasicFontSet">C Compiler</h3>
	{% for news in site.categories.C %}
        {% if news.title == 'C Compiler'%}
          <a class="Date">{{ news.date | date_to_string }}</a> | <a class="post-tag">{{ page.category }}</a>
        {% endif %}
        {% endfor %}
     </a>
	<blockquote><p class="posting">포스팅 </p></blockquote>
<h1 class="BasicFontSet">C 프로그래밍</h1>
	</br>
	프로그래밍이란 목적에 맞는 알고리즘으로부터 프로그래밍 언어를 사용하여 구체적인 프로그램을 작성하는 과정을 의미합니다.
	이렇게 작성된 프로그램은 먼저 실행 파일(executable file)로 변환되어야 실행할 수 있습니다.
	</br>
      <p class="Imgtext">
          <img src="/asset/Script/C/Compiler/Compiler1.png" class="concept"></br>
          <실행파일 생성></br>
      </p>

<p class="Paragraph">1. 소스 파일(Source file)의 작성</p>
	프로그래밍에서 가장 먼저 해야 할 작업은 프로그램을 작성하는 것 입니다.
	C언어를 문법에 맞게 논리적으로 작성된 프로그램을 원시 파일 또는 소스파일이라고 합니다.
	C언어를 통해 작성된 소프파일의 확장자는 .c가 됩니다.</br>
	</br>
<p class="Paragraph">2. 선행처리기(Preprocessor)에 의한 선행 처리</p>
	선행처리란 소스 파일 중에서도 선행처리 문자(#)로 시작하는 선행처리 지시문의 처리 작업을 의미합니다.
	코드를 생성하는 것이 아닌, 컴파일하기 전 컴파일러가 작업하기 좋도록 소스를 재구성해주는 역할만을 합니다.</br>
	</br>
<p class="Paragraph">3. 컴파일러(Compiler)에 의한 컴파일 </p>
	소스 코드를 컴파일하는 이유는 대부분 사람들에게 이해하기 쉬운 형태의 고수준 언어로부터 실행가능한 기계어 프로그램을 만들기 위해서이다.
	좁은 의미의 컴파일러는 주로 고수준 언어로 쓰인 소스 코드를 저수준 언어로 번역하는 프로그램을 가리킨다.
	컴퓨터는 0과 1로 이루어진 이진수로 작성된 기계어만을 이해할 수 있습니다.
	소스 파일은 개발자에 의한 C언어로 작성되므로, 컴퓨터는 그것을 바로 이해할 수 없습니다.
	따라서 소스 파일을 컴퓨터가 알아볼 수 있는 기계어로 변환시켜야 하는데, 그 작업을 컴파일(Compile)이라고 합니다.
	주로 다른 프로그램이나 하드웨어가 처리하기에 용이한 형태로 출력되지만 사람이 읽을 수 있는 문서 파일이나 그림 파일 등으로 옮기는 경우도 있다.</br>
	</br>
	컴파일은 컴파일러에 의해 수행되며, 컴파일이 끝나 기계어로 변환된 파일을 오브젝트 파일(Object file)이라고 합니다.
	이러한 오브젝트 파일의 확장자는 .o나 .obj가 됩니다.</br>
	</br>
<p class="Paragraph">4. 링커(Linker)에 의한 링크</p>
	컴파일러에 의해 생성된 오브젝트 파일은 운영체제와의 인터페이스를 담당하는 시동 코드(start-up code)를 가지고 있지 않습니다.
	또한, 대부분의 C 프로그램에서 사용하는 C 표준 라이브러리 파일도 포함되어 있지 않습니다.
	이때 하나 이상의 오브젝트 파일과 라이브러리 파일, 시동 코드 등을 합쳐 하나의 파일로 만드는 작업을 링크라고 합니다.</br>
	</br>
	링크는 링커(linker)에 의해 수행되며, 링크가 끝나면 하나의 새로운 실행 파일이나 라이브러리 파일이 생성됩니다.
	이처럼 여러 개의 소스 파일을 작성하여 최종적으로 링크를 통해 하나의실행 파일로 만드는 것을 분할 컴파일이라고 합니다.</br>
	</br>
<p class="Paragraph">5. 실행 파일(Executable file)의 생성</p>
	소스 파일은 선행처리기, 컴파일러 그리고 링커에 의해 위와 같은 과정을 거쳐 실행 파일로 변환됩니다.
	최근 사용되는 개발 툴은 대부분 위에서 소개한 선행처리기, 컴파일러, 링커를 모두 내장하고 있으므로, 소스 파일에서 한 번에 실행 파일을 생성해 줍니다.
	이렇게 생성된 파일의 확장자는 .exe가 됩니다.</br>
	</br>
	</br>
	</br>
<h2 class="BasicFontSet">원리</h2>
	컴파일러는 옮김의 과정에서 프로그램의 뜻을 보존하여야 한다. 입력받은 프로그램의 의미를 충실히 따라야한다.</br>
	-이 조건이 없다면 컴파일러를 사용하는 사용자가 컴파일러를 믿고 프로그램을 작성할 수도 없고, 잘못된 옮김을 인정한다면 컴파일러를 올바르게 하기 위한 노력을 들일 필요가 없을것이다.</br>
	</br>
	실용적인 면에서, 컴파일러는 입력으로 들어온 프로그램을 어떤 면에서든지 개선해야 한다.</br>
	- 소스코드를 기계어로 옮긴다면 기계가 이해할 수 없었던 언어를 기계가 이해할 수 있게 개선한 것이 된다.</br>
	</br>
	</br>
	</br>
<h2 class="BasicFontSet">기능</h2>
	고급언어를 직접 기계어 코드를 변환한다.
	자바의 경우 바이트 코드로 변환한다. 중간단계의 코드를 생성하고 이것을 해석해서 실행한다.</br>
	</br>
	C/C++언어와 같은 고급언어는 직접 기계어 코드로 변환한다. 마이크로프로세서는 각각 다른 기계어 코드를 가지고 있기 때문에 같은 고급언어라도 다른 기계어 코드를 생성해야 한다. 
	따라서 개발자는 해당 마이크로프로세서에 맞는 컴파일러 사용해야 한다.
	그러나 자바는 다양한 마이크로프로세서에서 실행되도록 하는 철학을 가지고 개발되었기 때문에 바이트 코드를 가지고 해석을 해서 실행하는 방식이다.
	장점은 한번 컴파일된 바이트 코드는 다른 플랫폼에서 재컴파일없이 실행할 수 있다. 
	그러나 단점은 바이트 코드를 해석해서 실행할 프로그램 구조가 필요하고, 직접 기계어 코드를 실행하는 것 보다 속도에서 늦다.
	</br>
	</br>
	</br>
<h2 class="BasicFontSet">컴파일러의 실행 단계</h2>
	많은 수의 컴파일러는 다음과 같은 순서를 거쳐 소스 코드를 번역한다.
	컴파일러나 프로그래밍 언어의 특성에 따라 일부 단계를 생략되거나 더 세부적인 단계로 나뉠 수도 있다.</br>
<p class="Paragraph">1. 구문 분석</p>
	소스 코드 파일을 읽어 개별 문법요소(연산자, 괄호, 식별자 등) 단위로 자른후, 이 문법요소들을 해석하여 추상 구문 트리를 생성한다. 
	이 과정에서 문법에 맞지 않는 소스 코드는 사용자에게 알려준다.</br>
<p class="Paragraph">2. 최적화</p>
	추상 구문 트리를 분석하여 최적화를 수행한다. 도달할 수 없는 코드를 식별하거나, 상수 표현식을 미리 계산해 두거나, 루프 풀기 등의 대부분의 최적화가 이 단계에서 수행된다.</br>
<p class="Paragraph">3. 코드 생성</p>
	최적화된 구문 트리로부터 목적 코드를 생성한다. 목표 언어가 기계어일 경우, 레지스터 할당, 연산 순서 바꾸기 등 하드웨어에 맞는 최적화가 이 단계에서 수행된다. </br>
	대부분의 하드웨어 최적화 알고리즘은 NP 복잡도를 갖지만, 휴리스틱을 통해 많은 최적화가 수행된다.</br>
<p class="Paragraph">4. 링킹</p>
	목적 코드가 기계어일 경우, 여러 라이브러리 목적 코드를 묶어 하나의 실행 파일을 생성하게 된다. </br>
	이 과정은 링커에 의해 수행되며, 어떤 사람들은 링커를 컴파일러의 일부로 간주하지 않기도 한다.</br>
	</br>
	</br>
	</br>
<h2 class="BasicFontSet">컴파일러의 구조</h2>
	컴파일러는 크게 어휘 분석과 구문 및 의미 분석, 코드 생성 단계로 나뉜다.
	컴파일러에 따라서는 선택적으로 구문 및 의미 분석과 코드 생성 단계 사이에 중간 코드를 생성하거나 코드를 최적화하기도 한다.
	일반적인 컨파일러의 구조는 아래와 같다.</br>
	</br>
      <p class="Imgtext">
          <img src="/asset/Script/C/Compiler/Compiler2.PNG" class="concept"></br>
          <일반적인 컴파일러의 ></br>
      </p>
	</br>
<p class="Paragraph">1. 어휘 분석</p>
	컴파일러의 첫 번째 단계는 소스 코드를 정규 문법 (regular grammar)에 따라 토큰(token)의 집합으로 변환하는 어휘 분석 또는 스캐닝(scanning)이다. 
	예를 들어, "Lexical analysis is the first step of compiler"라는 문장에서 'f', 'i', 'r', 's', 't'를 따로 놓으면 어떠한 의미도 없지만, "first"라는 하나의 문자열로 보면 "첫번째"라는 의미를 갖게 된다.
	어휘 분석은 문자열로 표현된 소스 코드에서 "first"와 같이 의미 있는 조각을 검출하는 단계이다. 
	어휘 분석 단계에서 검출되는 의미 있는 조각을 어휘항목(lexeme)이라고 하며, 어휘 분석기는 검출된 어휘항목을 참조하여 토큰을 생성한다.
	어휘 분석기가 출력하는 토큰은 토큰이름과 속성값으로 구성된다. 
	하나의 토큰은 토큰이름, 속성값과 같은 구조를 갖는다.
	예를 들어, 아래와 같은 코드가 어휘 분석기로 입력되었다고 가정하자. </br>
	</br>
	$value = threshold + distance$</br>
	</br>
	이 코드에서 "value"라는 문자열은 <id, 1>토큰으로 사상되는 어휘항목이다. 
	<id, 1>토큰에서 id는 토큰이름으로써 식별자를 의미하는 추상 기호이며, 속성값 1은 심볼 테이블 내에서 해당 토큰의 위치를 가리킨다. 
	토큰의 이름이나 속성값은 컴파일러 설계자에 따라 달라질 수 있다. 그 다음에 있는 '='라는 문자열은 토큰 <assign, NULL>로 사상된다. 
	이 토큰은 연산자 =를 가리키는 assign이라는 추상 기호를 토큰이름으로 갖으며, 심볼 테이블에 입력될 필요가 없기 때문에 속성값은 NULL을 갖는다. 
	어휘 분석기가 위의 코드를 모두 토큰으로 사상하면, 아래와 같은 토큰 스트림이 생성된다.</br>
	</br>
	$<'id', 1>, <'assign', 'NULL'>, <'id', 2>, <'plus', 'NULL'>, <'id', 3>$</br>
	</br>
<p class="Paragraph">2. 구문 분석</p>
	어휘 분석 다음 단계는 소스 코드의 문법을 검사하는 구문 분석 또는 파싱 (parsing)이라 한다. 
	구문 분석기는 어휘 분석기에서 출력한 토큰들을 이용하여 소스 코드의 문법 구조를 서술하는 구문 트리(syntax tree)를 생성한다. 
	구문 트리는 어휘 분석기에서 생성한 토큰들을 노드로 갖는 트리로써, 토큰 간의 우선순위 및 토큰간의 결합 관계 등과 같은 속성을 나타낸다.
	구문 분석의 목적은 토큰 간의 관계가 올바르게 생성되었는지를 검사하는 것이다.
	예를 들어, "I is a student"라는 문장이 입력되었을 때, 어휘 분석기는 <1인칭 주어,1>과 <3인칭 동사, 2>라는 토큰을 생성하고, 구문 분석기에 전달한다. 
	구문 분석기에서는 1인칭 주어와 3인칭 동사가 사용된 것이 잘못되었음을 인식하여 구문 에러를 출력한다. 
	토큰 간의 관계를 서술하고, 소스 코드에 잘못된 토큰 간의 관계가 있는지를 검사하는 것이 구문 분석의 목적이다.</br>
	</br>
<p class="Paragraph">3. 의미 분석</p>
	의미 분석 단계에서는 구문 트리와 심볼 테이블에 있는 정보를 이용하여 소스 코드가 언어 정의에 의미적으로 부합하는지를 검사한다. 
	의미 분석의 중요한 기능은 타입 검사 (type checking)이다. 
	컴파일러는 타입 검사를 수행하면서 피연산자가 연산자에 부합하는지를 검사한다. 
	의미 분석기는 정수와 문자열의 덧셈, 값을 0으로 나누는 행동 등과 같이 의미적으로 올바르지 않은 코드의 존재 유무를 검사한다.
	예를 들어, "The earth revolves around the moon"라는 문장은 영어라는 인간언어에 존재하는 어휘항목만을 사용하였고, 주어와 동사가 일치하며 "revolve" 다음에 올 수 있는 "around"라는 부사까지 올바르게 사용하였지만, 의미적으로는 "지구가 달을 공전한다"는 틀린 문장이다.
	의미 분석의 어려운 점은 의미 분석이라는 연산이 수학적으로 완벽하지 않다는 것 때문에 발생한다. 
	위의 "The earth revolves around the moon"이라는 문장도 의미적으로는 틀린 문장이지만, 저 문장이 사용되는 배경이 소설이나 영화라면 무조건 틀렸다고 할 수도 없다. 
	이러한 경우와 같이 의미 분석은 어휘 분석이나 구문 분석과는 다르게 수학적으로 일정한 규칙을 갖지 않고, 의미를 해석한다는 연산 자체에 모호한 부분이 있기 때문에 의미 분석에는 많은 어려움이 존재한다. 
	이전의 어휘 분석기나 구문 분석기는 독립적으로 실행되어 출력을 만들어냈지만, 의미 분석기는 이러한 난해함 때문에 이전 단계에서 생성한 구문 트리와 심볼 테이블을 참조하면서 의미 분석을 수행해야 한다.</br>
	</br>
<p class="Paragraph">4. 코드 생성</p>
	이전 단계를 통해 분석된 소스 코드를 목표 기계에 맞는 어셈블리어나 기계어로 변환하는 단계이다. 
	컴파일 타임 바인딩을 이용하는 시스템의 경우에는 코드 생성 단계에서 프로그램의 기억 장소 할당이 이루어진다. 
	상용 컴파일러에서는 의미 분석 단계와 코드 생성 단계 중간에 코드 최적화 단계가 추가되는데, 코드 최적화 단계는 해당 언어의 성능이나 자원 소모를 결정짓는 중요한 단계이다. 
	그러나 코드 최적화 단계는 컴파일러보다는 컴퓨터 구조에 대한 지식을 요구하는 단계로써, 컴파일러의 원리를 배우는 입장에서는 코드 최적화 단계라는 것의 중요성과 이것이 의미 분석 단계와 코드 생성 단계 사이에 있다는 사실 정도만 인지하고 있어도 충분하다.</br>
	<blockquote><p class="Reference">가져온곳: <a class="Reference"> URL</a></p></blockquote>
  </body>
</html>
