---
layout: post
title: DOM, CSSOM Optimization
meta: Compare
category: ComparativeAnalysis
comments: true
---
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css">
    <link rel="stylesheet" type="text/css" href="/css/pageframe.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <style>
      @import url(//fonts.googleapis.com/earlyaccess/nanumpenscript.css);
    </style>
  </head>
  <body>	  
<!--
카테고리: Categories <h3 class="Categories BasicFontSet"></h3>
날짜: Date 
      {% for news in site.categories.analysis %}
        {% if news.title == 'Testing css'%}
          <a class="Date">{{ news.date | date_to_string }}</a> | <a class="post-tag">{{ page.category }}</a>
        {% endif %}
      {% endfor %}
태그: Tags <a class="post-tag">태그 내용</a>
posting한곳: Posting <blockquote><p class="posting">포스팅 </p></blockquote>
주제: MainTitle <h1 class="BasicFontSet"></h1>
소제: SubTitle <h2 class="BasicFontSet"></h2>
단락: Paragraph <p class="Paragraph"></p>
내용: Contents <p class="Contents"></p>
이미지: Imgsize - media query 적용
이미지 text: Imgtext
      <p class="Imgtext">
          <img src="이미지 주소"></br>
          <내용></br>
      </p>
전체 코드 URL: CodeURL
참고자료: Reference <blockquote><p class="Reference">가져온곳: <a class="Reference"> URL</a></p>
-->
      <a>
	<h3 class="Categories BasicFontSet">DOM, CSSOM Optimization</h3>
	{% for news in site.categories.ComparativeAnalysis %}
        {% if news.title == 'DOM, CSSOM Optimization'%}
          <a class="Date">{{ news.date | date_to_string }}</a> | <a class="post-tag">{{ page.category }}</a>
        {% endif %}
        {% endfor %}
<blockquote><p class="posting">포스팅 </p></blockquote>
<h1 class="BasicFontSet">주요 렌더링 경로</h1>

브라우저가 HTML,CSS 및 JavaScript를 사용하여 화면에 렌더링된 픽셀로 변환하는 과정을 알아보자.
성능을 최적화하려면 HTML, CSS 및 자바스크립트 바이트를 수신한 후 렌더링된 픽셀로 변환하기 위해 필요한 처리까지, 
그 사이에 포함된 중간 단계에서 어떠한 일이 일어나는지를 파악하기만 하면 됩니다. 
이러한 단계가 바로 주요 렌더링 경로입니다.
<이미지>
주요 렌더링 경로를 최적화하면 최초페이지 렌더링에 걸리는 시간을 상당히 단축시킬 수 있다.
또한, 주요 렌더링 경로에 대한 이해를 토대로 뛰어난 성능의 대화형 애플리케이션을 빌드할 수도 있습니다.
대화형 업데이트 프로세스도 이와 동일합니다. 연속 루프에서 실행되며 이상적인 속도는 초당 60프레임입니다.


<h2 class="BasicFontSet">객체 모델 생성</h2>

브라우저가 페이지를 렌더링하려면 먼저 DOM 및 CSSOM트리를 생성해야 합니다.
따라서 HTML 및 CSS를 가능한 빨리 브라우저에 제공해야 합니다.

ㅇ바이트 → 문자 → 토큰 → 노드 → 객체 모델.
ㅇHTML 마크업은 DOM(Document Object Model)으로 변환되고,
	 CSS 마크업은 CSSOM(CSS Object Model)으로 변환됩니다.
ㅇDOM 및 CSSOM은 서로 독립적인 데이터 구조입니다.
ㅇChrome DevTools Timeline을 사용하면 DOM 및 CSSOM의 
	생성 및 처리 비용을 수집하고 점검할 수 있습니다.

<h2 class="BasicFontSet">DOM(Document Object Model)</h2>
</br>
</br>
<pre><code>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="style.css" rel="stylesheet">
    <title>Critical Path</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg"></div>
  </body>
</html>
</br>
</br>
가장 단순한 경우인 몇몇 텍스트와 하나의 이미지만 포함하는 일반 HTML 페이지부터 
살펴보도록 하겠습니다. 브라우저가 이 페이지를 어떻게 처리하나요?
<이미지>
1. 변환
2. 토큰화
3. 렉싱
4. DOM 생성
이 전체 프로세스의 최종 출력이 바로 이 간단한 페이지의 DOM이며, 브라우저는 이후 모든 페이지 처리에
이 DOM을 사용합니다.

브라우저는 HTML마크업을 처리할 때마다 위의 모든 단계를 수행합니다. 즉, 바이트를 문자로 변환하고,
토큰을 식별한 후 노드로 변환하고 DOM트리를 빌드합니다. 이 전체 프로세스를 완료하려면 시간이
약간 걸릴 수 있으며, 특히 처리해야 할 HTML이 많은 경우 그렇습니다.
<이미지>
참고: Chrome DevTools 사용방법에 대해 알아야함. - 네트워크 워터폴을 캡처하거나 타임라인을 기록하는 방법
Discover DevTools 학습: https://www.pluralsight.com/search?q=chrome%20developer%20tools
매끄러운 애니메이션을 만드는 경우, 브라우저가 대량의 HTML을 처리해야 한다면 쉽게 병목 현상이 발생할 수 있습니다.

DOM트리는 문서 마크업의 속성 및 관계를 포함하지만 요소가 렌더링될 때 어떻게 표시될지에 대해서는
알려주지 않습니다. 이것은 CSSOM의 책임입니다.

<h2 class="BasicFontSet">CSSOM(CSS Object Model)</h2>
브라우저는 단순한 페이지의 DOM을 생성하는 동안 외부 CSS 스타일시트인 style.css를 참조하는 문서의
헤드 섹션에서 링크 태그를 접합니다. 페이지를 렌더링하는데 이 리소스가 필요할 것이라고 판단한 브라우저는
이 리소스에 대한 요청을 즉시 발송하고 요청의 결과로 다음 콘텐츠가 반환됩니다.
</br>
</br>
<pre><code>
body { font-size: 16px }
p { font-weight: bold }
span { color: red }
p span { display: none }
img { float: right }
</code></pre>
</br>
</br>
HTML 마크업내에 직접 스타일을 선언할 수도 있지만 CSS를 HTML과 별도로 유지하면 콘텐츠와 디자인을
별도의 항목으로 처리할 수 있습니다. 즉, 디자이너는 CSS를 처리하고, 개발자는 HTML에만 집중할 수 있습니다.

HTML과 마찬가지로, 수신된 CSS 규칙을 브라우저가 이해하고 처리할 수 잇는 형식으로 변환해야 합니다.
따라서 HTML 대신 CSS에 대해 HTML프로세스를 반복합니다.
<이미지>
CSS바이트가 문자로 변환된 후 차례로 토큰과 노드로 변환되고 마지막으로 'CSS Object Model'(CSSOM)이라는
트리 구조에 링크됩니다.
<이미지>
CSSOM이 트리 구조를 가지는 이유느 페이지에 있는 객체의 최종 스타일을 계산할 때 브라우저는 해당노드에
적용 가능한 가장 일반적인 규칙(EX: body요소의 하위인 경우 모든 body 스타일 적용)으로 시작한 후 더욱 구체적인 규칙을 적용하는 방식으로
계산된 스타일을 재귀적으로 세분화합니다.
CSSOM 및 DOM은 서로 독립적인 데이터 구조입니다. 알고보니 브라우저에서 숨겨진 중요한 단계가 있습니다.


<h2 class="BasicFontSet">렌더링 트리 생성, 레이아웃 및 페인트</h2>

CSSOM 및 DOM트리는 결합하여 렌더링 트리를 형성합니다. 이 렌더링 트리는 표시되는 각 요소의 레이아웃을
계산하는 데 사용되고 픽셀을 화면에 렌더링하는 페인트 프로세스에 대한 입력으로 처리됩니다.
최적의 렌더링 성능을 얻기 위해서는 이러한 단계 각각을 최적화하는 것이 중요합니다.

객체 모델을 생성하는 방법을 설명한 이전 섹션에서 우리는 HTML 및 CSS 입력을 기반으로 DOM 및 CSSOM 트리를 빌드했습니다.
하지만, 이들 모두 문서의 각기 다른 측면을 캡처하는 서로 독립적인 객체입니다. 하나는 콘텐츠를 설명하고,
다른 하나는 문서에 적용되어야 하는 스타일 규칙을 설명합니다. 이 두 가지를 병합하여 브라우저가 화면에 픽셀을 렌더링하도록 하려면
어떻게 해야 할까요?

DOM 및 CSSOM 트리는 결합되어 렌더링 트리를 형성합니다.
렌더링 트리에는 페이지를 렌더링하는 데 필요한 노드만 포함됩니다.
레이아웃은 각 객체의 정확한 위치 및 크기를 계산합니다.
마지막 단계는 최종 렌더링 트리에서 수행되는 페인트이며, 픽셀을 화면에 렌더링합니다.

먼저, 브라우저가 DOM 및 CSSOM을 '렌더링 트리'에 결합합니다. 이 트리는 페이지에 표시되는 
모든 DOM 콘텐츠와 각 노드에 대한 모든 CSSOM 스타일 정보를 캡처합니다.
<이미지>
렌더링 트리를 생성하려면 브라우저가 대략적으로 다음 작업을 수행합니다.
1. DOM 트리의 q루트에서 시작하여 표시되는 노드 각각을 트래버스합니다.
	일부 노드는 표시되지 않으며, 렌더링된 출력에 반영되지 않으므로 생략됩니다.
	일부 노드는 CSS를 통해 숨겨지며 렌더링 트리에서도 생량됩니다.
	예를 들어, 노드의 경우 속성을 설정하는 명시적 규칙이 있기 때문에 렌더링 트리에서 누락됩니다.
2. 표시된 각 노드에 대해 적절하게 일치하는 CSSOM 규칙을 찾아 적용합니다.
3. 표시된 노드를 콘텐츠 및 계산된 스타일과 함께 내보냅니다.

최종 출력은 화면에 표시되는 모든 노드의 콘텐츠 및 스타일 정보를 모두 포함하는 렌더링 트리입니다.
렌더링 트리가 생성되었응므로 '레이아웃' 단계로 진행할 수 있습니다.

지금까지 표시할 노드와 해당 노드의 계산된 스타일을 계산했습니다. 
<blockquote><p class="Reference">출처: <a class="Reference">
https://developers.google.com/web/fundamentals/performance/critical-rendering-path/
https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction
</a></p></blockquote>

     </a>
  </body>
</html>
