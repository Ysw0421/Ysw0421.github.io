---
layout: post
title: InfluxDB
meta: Concept
category: DB
comments: true
---
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css">
    <link rel="stylesheet" type="text/css" href="/css/pageframe.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <style>
      @import url(//fonts.googleapis.com/earlyaccess/nanumpenscript.css);
    </style>
  <!--
  수식용 스크립트 MathJax
  -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      //jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$'] ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
      //,
      //displayAlign: "left",
      //displayIndent: "2em"
    });
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
  </head>
  <body>	  
<!--
카테고리: Categories <h3 class="Categories BasicFontSet"></h3>
날짜: Date 
      {% for news in site.categories.analysis %}
        {% if news.title == 'Testing css'%}
          <a class="Date">{{ news.date | date_to_string }}</a> | <a class="post-tag">{{ page.category }}</a>
        {% endif %}
      {% endfor %}
태그: Tags <a class="post-tag">태그 내용</a>
posting한곳: Posting <blockquote><p class="posting">포스팅 </p></blockquote>
주제: MainTitle <h1 class="BasicFontSet"></h1>
소제: SubTitle <h2 class="BasicFontSet"></h2>
단락: Paragraph <p class="Paragraph"></p>
내용: Contents <p class="Contents"></p>
이미지: Imgsize - media query 적용
이미지 text: Imgtext
      <p class="Imgtext">
          <img src="이미지 주소" class="concept"></br>
          <내용></br>
      </p>
전체 코드 URL: CodeURL
참고자료: Reference <blockquote><p class="Reference">가져온곳: <a class="Reference"> URL</a></p>
-->
      <a>
	<h3 class="Categories BasicFontSet">InfluxDB</h3>
	{% for news in site.categories.DB %}
        {% if news.title == 'InfluxDB'%}
          <a class="Date">{{ news.date | date_to_string }}</a> | <a class="post-tag" href="https://ysw0421.github.io/contents/categories/#DB">{{ page.category }}</a>
        {% endif %}
        {% endfor %}
     </a>
	<blockquote><p class="posting">포스팅 </p></blockquote>
<h2 class="BasicFontSet">Comparison to SQL</h2>
	InfluxDB는 시계열 데이터로 작동하도록 설계되었습니다.
	SQL 데이터베이스는 시계열을 처리할 수 있지만 그 목적을 위해 엄격하게 생성된 것은 아닙니다. 
	즉, InfluxDB는 대량의 시계열 데이터를 저장하고 이러한 데이터에 대한 실시간 분석을 신속하게 수행하도록 만들어졌습니다.</br>
	</br>
	InfluxDB에서 타임 스탬프는 주어진 데이터 시리즈에서 단일 지점을 식별합니다.
	또한 InfluxDB는 Schema 기본 설정이 시간이 지나면 변경될 수 있음을 인식합니다. 
	InfluxDB에서는 스키마를 정의할 필요가 없습니다.
	데이터 포인트는 측정 값의 필드 중 하나, 측정 값의 모든 필드 또는 그 사이의 임의의 수를 가질 수 있습니다.
	새로운 필드에 포인트를 쓰는 것만으로 새로운 필드를 측정에 추가할 수 있습니다.</br>
<페이블 예시 1.></br>
	InfluxDB Measurement는 SQL 데이터베이스 테이블과 유사합니다.
	InfluxDB Tag는 SQL 데이터베이스의 인덱싱된 열과 같습니다.
	InfluxDB Point는 SQL 행과 유사합니다.</br>
	</br>
	이 데이터 베이스 용어 비교를 기반으로 InfluxDB의 지속적인 쿼리와 보존 정책은 SQL데이터베이스의 Stored Procedure와 유사합니다. 
	그것들은 한번 지정되고 정기적으로 그리고 자동적으로 수행됩니다.</br>
	</br>
	물론 SQL 데이터베이스와 InfluxDB 간에는 큰 불균형이 있습니다. 
	SQL JOIN은 InfluxDB Meaurement에는 사용할 수 없습니다.
	스키마 설계에는 그 차이가 반영되어야합니다.
	그리고 위에서 언급했듯이 측정 값은 기본 인덱스가 항상 사전 설정되어있는 SQL 테이블과 같습니다. 
	InfluxDB Time Stamp는 시간 문자열 형식이어야합니다.</br>
	</br>
	</br>
	<p class="Paragraph">InfluxQL 과 SQL</p>
	InfluxQL은 InfluxDB와 상호 작용할 수 있는 SQL과 유사한 쿼리 언어입니다. 
	또한 다른 SQL 또는 SQL과 같은 환경에서 온 사람들에게 익숙한 느낌을 주며 시계열 데이터를 저장하고 분석하는 기능을 제공합니다.</br>
	</br>
	</br>
<p class="Paragraph">InfluxDB가 CRUD가 아닌 이유에 대한 설명</p>
	InfluxDB는 시계열 데이터에 최적화 된 데이터베이스입니다. 
	이 데이터는 일반적으로 분산 센서 그룹, 대형 웹 사이트의 클릭 데이터 또는 금융 거래 목록과 같은 출처에서 가져옵니다.</br>
	</br>
	이 데이터의 공통점 중 하나는 집계에서 더 유용하다는 것입니다. 
	나머지 시리즈와 결합하여 시각화하면 더욱 유용해집니다.
	여기에 시간에 따른 추세가 나타나기 시작하고 데이터에서 실행 가능한 통찰력을 얻을 수 있습니다. 
	또한 시계열 데이터는 일반적으로 한 번 작성되고 거의 업데이트되지 않습니다.</br>
	</br>
	결과적으로 InfluxDB는 완전한 CRUD 데이터베이스가 아니라 CR-ud와 같아서 업데이트 및 파괴에 대한 데이터 작성 및 읽기의 우선 순위를 지정하고 일부 업데이트 및 파괴 동작을 방지하여 작성 및 읽기 성능을 향상시킵니다.</br>
	</br>
	</br>
	</br>
<h2 class="BasicFontSet">Main Concept</h2>
<h2 class="BasicFontSet">Design Insights and Tradeoffs in InfluxDB</h2>
	InfluxDB는 시계열 데이터베이스입니다. 
	이 UseCase에 맞게 최적화하면 주로 기능을 희생하여 성능을 향상시키는 몇 가지 단점이 있습니다. 
	다음은 절충안으로 이어진 몇 가지 디자인 통찰력 목록입니다.</br>
	<b>1. 시계열 사용 사례의 경우 동일한 데이터가 여러번 전송되는 경우 클라이언트가 방금 보낸 동일한 데이터라고 가정합니다.</b></br>
	절충안 : 단순화된 충돌 해결로 쓰기 성능 향상</br>
	단점 : 중복 데이터를 저장할 수 없습니다. 드물기는하지만 데이터를 덮어쓸 수있다.</br>
	</br>
	<b>2. 삭제는 거의 발생하지 않습니다. 그것들이 발생했을 때, 거의 항상 오래된 데이터가 기록을 위해 차가워지는 것에 반대합니다.</b></br>
	절충안 : 삭제에 대한 액세스를 제한하여 쿼리 및 쓰기 성능 향상</br>
	단점 : 삭제 기능이 크게 제한됩니다.</br>
	</br>
	<b>3. 기존 데이터에 대한 업데이트는 거의 발생하지 않으며 논쟁의 여지가 없는 업데이트가 발생하지 않습니다.
	시계열 데이터는 업데이트되지 않는 우세한 새로운 데이터입니다.</b></br>
	절충안 : 업데이트에 대한 액세스를 제한하여 쿼리 및 쓰기 성능 향상</br>
	단점 : 업데이트 기능이 크게 제한됩니다.</br>
	</br>
	<b>4. 대다수의 쓰기는 매우 최근의 시간 소인이있는 데이터 용이며 데이터는 시간 오름차순으로 추가됩니다.</b></br>
	절충안 : 시간 오름차순으로 데이터를 추가하는 것이 훨씬 더 효과적입니다.</br>
	단점 : 임의의 시간 또는 시간이 오름차순이 아닌 점을 쓰는 것은 훨씬 덜 효과적입니다.</br>
	</br>
	<b>5. 규모가 중요합니다. 
	데이터베이스는 대량의 읽기 및 쓰기를 처리 할 수 있어야합니다.</b></br>
	절충안 : 데이터베이스는 대량의 읽기 및 쓰기를 처리할 수 있습니다.</br>
	단점 : InfluxDB 개발 팀은 성능을 향상시키기 위해 절충안을 사용해야했습니다.</br>
	</br>
	<b>6. 강력하게 일관된 시각을 갖는 것보다 데이터를 쓰고 쿼리하는 것이 더 중요합니다.</b></br>
	절충안 : 데이터베이스 작성 및 쿼리는 여러 클라이언트와 높은 로드에서 수행할 수 있습니다.</br>
	단점 : 데이터베이스에 부하가 많은 경우 쿼리 반환 값에 가장 최근의 포인트가 포함되지 않을 수 있습니다.</br>
	</br>
	<b>7. 많은 Time-Series가 일시적입니다. 
	몇 시간 동안만 나타나고 사라지는 시계열이 종종 있습니다. 
	예를 들어 새로운 호스트가 시작되고 잠시 동안보고 된 다음 종료됩니다.</b></br>
	절충안 : InfluxDB는 불연속 데이터 관리에 능숙합니다.</br>
	단점 : 스키마가없는 디자인은 일부 데이터베이스 기능이 지원되지 않는다는 것을 의미합니다. 즉, 크로스 테이블 조인이 없습니다.</br>
	</br>
	<b>8. 아무리 강조해도 중요하지 않습니다.</b></br>
	절충안 : InfluxDB는 집계 데이터 및 대용량 데이터 세트를 처리 할 수 있는 매우 강력한 도구를 제공합니다.</br>
	단점 : 포인트는 전통적인 의미에서 ID를 갖지 않으며 타임 스탬프와 시리즈로 구분됩니다.</br>
<h2 class="BasicFontSet">Schema & Data Layout</h2>
<p class="Paragraph">권장되는 스키마 디자인</p>
	특별한 순서없이 다음과 같이하는 것이 좋습니다.</br>
<b>메타 데이터를 태그로 인코딩</b></br>
	Tags는 인덱싱되고 Fields는 인덱싱되지 않습니다. 즉, 태그에 대한 쿼리가 필드에 대한 쿼리보다 성능이 좋습니다.</br>
	</br>
	일반적으로 검색어는 태그로 저장된 내용과 필드로 저장되는 내용을 안내해야합니다.</br>
	</br>
	1. 데이터를 자주 쿼리하는 메타 데이터인 경우 태그에 데이터 저장</br>
	2. GROUP BY()와 함께 사용할 계획이라면 데이터를 태그에 저장하십시오.</br>
	3. InfluxQL 함수와 함께 사용할 계획이라면 데이터를 필드에 저장하십시오.</br>
	4. 문자열이 아닌 다른 문자열이 필요한 경우 필드에 데이터 저장 - 태그 값은 항상 문자열로 해석됩니다.</br>
	</br>
	<b>InfluxQL 키워드를 식별자 이름으로 사용하지 마십시오.</b></br>
	이것은 필수는 아니지만 쿼리 작성을 단순화합니다. 식별자를 큰 따옴표로 묶을 필요가 없습니다. </br>
	식별자는 데이터베이스 이름, 보존 정책 이름, user 이름, measurement 이름, 태그 키 및 필드 키입니다. </br>
	피할 단어에 대해서는 InfluxQL 키워드를 참조하십시오.</br>
	</br>
	[Az,_] 이외의 문자가 포함되어있는 경우에는 식별자를 큰 따옴표로 묶어야합니다.</br>
<h2 class="BasicFontSet">Storage Engine</h2>
	추후 업데이트 예정(안될 수도 있음..)</br>
	https://code.i-harness.com/ko-kr/docs/influxdata/influxdb/v1.3/concepts/storage_engine/index</br>
	<blockquote><p class="Reference">가져온곳: <a class="Reference"> https://code.i-harness.com/ko-kr/docs/influxdata/influxdb/v1.3/concepts/index</a></p></blockquote>
  </body>
</html>
